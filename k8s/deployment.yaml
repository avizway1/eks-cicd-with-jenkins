# =============================================================================
# Deployment — Rolling update strategy
# IMAGE_PLACEHOLDER is replaced by the Jenkins pipeline with the full ECR URI
# e.g. 123456789012.dkr.ecr.ap-south-1.amazonaws.com/eks-cicd:42
# =============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: eks-cicd-app
  namespace: eks-cicd
  labels:
    app: eks-cicd-app
    team: avizway
    app.kubernetes.io/name: eks-cicd-app
    app.kubernetes.io/managed-by: jenkins
  annotations:
    deployment.kubernetes.io/revision: "1"
spec:
  # Enough replicas for HA; adjust per node capacity
  replicas: 2

  selector:
    matchLabels:
      app: eks-cicd-app

  # ── Rolling update strategy ───────────────────────────────────────────────
  # maxUnavailable=0  → zero-downtime: bring new pods up first
  # maxSurge=1        → one extra pod spun up at a time (conservative)
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1

  template:
    metadata:
      labels:
        app: eks-cicd-app
        version: "latest"
      annotations:
        # Force pod restart on every deploy even if only tag changed
        rollme: "${RANDOM}"
    spec:
      # ── Security context (pod-level) ────────────────────────────────────
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        fsGroup: 1001

      # ── Graceful shutdown ───────────────────────────────────────────────
      terminationGracePeriodSeconds: 30

      # ── Pull image using node's IAM role (ECR) ──────────────────────────
      # No imagePullSecret needed — the node instance profile has ECR read access.

      containers:
        - name: eks-cicd-app
          # Jenkins replaces IMAGE_PLACEHOLDER before kubectl apply
          image: IMAGE_PLACEHOLDER
          imagePullPolicy: Always

          ports:
            - name: http
              containerPort: 8080
              protocol: TCP

          # ── Environment variables ─────────────────────────────────────
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "prod"
            - name: APP_VERSION
              valueFrom:
                fieldRef:
                  fieldPath: metadata.labels['version']

          # ── Resource limits ───────────────────────────────────────────
          # Requests: guaranteed allocation by the scheduler
          # Limits:   hard cap — pod is OOMKilled if exceeded
          resources:
            requests:
              cpu: "250m"       # 0.25 vCPU
              memory: "256Mi"
            limits:
              cpu: "500m"       # 0.5 vCPU
              memory: "512Mi"

          # ── Liveness probe ────────────────────────────────────────────
          # Kubernetes restarts the container if this fails.
          # Spring Boot Actuator exposes /actuator/health/liveness
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: http
            initialDelaySeconds: 30   # Give JVM time to warm up
            periodSeconds: 15
            failureThreshold: 3
            timeoutSeconds: 5

          # ── Readiness probe ───────────────────────────────────────────
          # Traffic is only routed to a pod when this passes.
          # Spring Boot Actuator exposes /actuator/health/readiness
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: http
            initialDelaySeconds: 20
            periodSeconds: 10
            failureThreshold: 3
            timeoutSeconds: 5

          # ── Startup probe ─────────────────────────────────────────────
          # Disables liveness/readiness until the app has fully started.
          # Prevents premature kills during slow cold-start.
          startupProbe:
            httpGet:
              path: /actuator/health/liveness
              port: http
            initialDelaySeconds: 10
            periodSeconds: 5
            failureThreshold: 12    # 12 × 5 s = 60 s max startup time

          # ── Container security context ────────────────────────────────
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL

          # ── Temp dirs needed by Spring Boot / JVM ─────────────────────
          volumeMounts:
            - name: tmp-dir
              mountPath: /tmp

      volumes:
        - name: tmp-dir
          emptyDir: {}

      # ── Pod anti-affinity ─────────────────────────────────────────────────
      # Prefer scheduling replicas on different nodes (soft rule).
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - eks-cicd-app
                topologyKey: "kubernetes.io/hostname"
